{
    "id": "386",
    "lang": "fa",
    "content": [
      {"topTitle": "مطالعه موردی جهانی"},
      {"mainTitle": "چگونه فیس‌بوک مسنجر با کاهش بدهی فنی سرعت و کارایی خود  را افزایش داد"},
      {"subTitle": "فیس‌بوک مسنجر با بیش از یک میلیارد کاربر در سراسر جهان، به ابزاری اساسی برای ارتباطات تبدیل شد. اما در پشت صحنه با مشکلی رایج در نرم‌افزارهای در حال رشد دست و پنجه نرم می‌کرد: بدهی فنی"},
      {"infoBox": [
        {"title": "منتشر شده در", "subTitle": "۴ مارس ۲۰۲۰"},
        {"title": "مدت زمان مطالعه", "subTitle": "۱۲ دقیقه"},
        {"title": "دسته‌بندی", "subTitle": "توسعه اپلیکیشن"}
      ]},
      {"image": "/facebook-banner.svg"},
      {"title": "تولد مسنجر و رشد برق‌آسا در ازای بدهی‌های فنی و افت سرعت"},
      {"p": "مسنجر در سال ۲۰۱۱ به عنوان یک اپلیکیشن چت ساده که از دل اپلیکیشن اصلی فیسبوک جدا شده بود، معرفی شد. در سال ۲۰۱۳ تماس صوتی و در سال ۲۰۱۵ تماس تصویری به آن اضافه شد. تا سال ۲۰۱۸ کاربران می‌توانستند بدون خروج از مسنجر پول جابه‌جا کنند، اوبر سفارش دهند، بازی‌های سبک انجام دهند، تماس‌های گروهی برقرار کنند و حتی با چت‌‌بات‌ها گفتگو کنند."},
      {"p": "افزایش قابلیت‌های مسنجر باعث رشد چشمگیر تعداد کاربران فعال روزانه شد، اما هر قابلیت جدید در کنار مزایایش، چالش‌های فنی هم به همراه داشت. حجم کد پروژه بیشتر می‌شد، نسخه‌های مختلفی از اپلیکیشن باید ساخته و پشتیبانی می‌شد، سرویس‌های پس‌زمینه‌ی بیشتری لازم بود و در نتیجه، احتمال بروز باگ‌های پیچیده و موارد لبه‌ای هم افزایش پیدا می‌کرد."},
      {"p": "فرهنگ مدیریتی فیس‌بوک با شعار «سریع حرکت کن» شناخته می‌شود. اما جنبه‌ی پنهان این رویکرد آن است که کدبیس‌ها با همین سرعت می‌توانند دچار انباشت بدهی فنی و پیچیدگی بیش از حد شوند. چیزی که اغلب سریع‌تر از پیش‌بینی اتفاق می‌افتد."},
      {"p": "در iOS، حجم باینری مسنجر به حدود ۱۳۰ مگابایت رسیده بود؛ به‌شدت نزدیک به سقف ۲۰۰ مگابایتی اپل برای دانلود از طریق شبکه موبایل. داشبوردهای مهندسی نیز روندهای نگران‌کننده‌ای را نشان می‌دادند:"},
      {"ul": [
        {"li": "زمان راه‌اندازی اولیه (cold start) در گوشی‌های پرچمدار از دو ثانیه عبور کرده بود."},
        {"li": "در دستگاه‌های قدیمی‌تر، شاهد افت عملکرد دورقمی بودیم."},
        {"li": "نقاط مهمی در مسیرهای کلیدی برنامه بدون تست کافی باقی مانده بودند (code-coverage gaps)."}
      ]},
      {"p": "به‌تنهایی، هیچ‌کدام از این شاخص‌ها بحرانی نبودند. اما در کنار هم به یک مسأله‌ی اساسی اشاره می‌کردند: مسنجر به میدان مینِ بدهی‌های فنی تبدیل شده بود. تیم‌های مهندسی به جای توسعه‌ی قابلیت‌های جدید، عمدتا درگیر مدیریت معماری قدیمی و حل مشکلات ساختاری بودند — وضعیتی که در مهندسی نرم‌افزار با عنوان «مالیات نوآوری» شناخته می‌شود."},
      {"title": "مواجهه با حقیقت تلخ: زمانی که شاخص‌ها از خط قرمز عبور کردند"},
      {"p": "فرهنگ فیسبوک به‌شدت داده‌محور است و برای هر قابلیت مهم، یک داشبورد دقیق از شاخص‌های عملکردی وجود دارد. این ویژگی در این مقطع به کار تیم مسنجر آمد: زمانی که مدیران به دنبال یک دلیل قاطع و مستند برای آغاز یک بازنگری جدی بودند. در نهایت، دو عدد کلیدی مسیر را روشن کرد:"},
      {"ul": [
        {"li": "زمان راه‌اندازی بیش از ۲ ثانیه: مطالعات داخلی در حوزه‌ تجربه‌ کاربری نشان داده بودند که زمان راه‌اندازی بالاتر از ۱.۵ ثانیه، به کاهش قابل توجه تعامل کاربران می‌انجامد."},
        {"li": "حجم باینری ۱۳۰ مگابایت: با ادامه‌ی این روند، پیش‌بینی می‌شد که طی ۱۸ ماه حجم برنامه از سقف ۲۰۰ مگابایتی اپل عبور کند؛ که در این صورت یا باید ویژگی‌هایی حذف می‌شدند، یا کاربران جدید امکان دانلود برنامه از طریق اینترنت موبایل را از دست می‌دادند."}
      ]},
      {"p": "هرچند بسیاری از اپلیکیشن‌ها با زمان راه‌اندازی دو ثانیه هم به حیات خود ادامه می‌دهند، اما در مقیاس جهانی کاربران مسنجر، این وضعیت قابل قبول نبود — به‌ویژه روی گوشی‌های میان‌رده. وقتی میانگین زمان راه‌اندازی در آیفون دو ثانیه باشد، در گوشی‌های ۱۰۰ دلاری بازارهایی مانند برزیل یا هند این زمان می‌تواند به سه یا چهار ثانیه برسد — که برای یک ابزار چت آنلاین کاملا غیرقابل قبول است."},
      {"p": "در چنین شرایطی، نیاز به یک تغییر بنیادی آشکار شد. مدیران پروژه تصمیم گرفتند بزرگ‌‌ترین بازنگری کد در تاریخ مسنجر را آغاز کنند: یک ممیزی داخلی تمام‌عیار."},
      {"title": "کالبدشکافی یک بازنگری عمیق داخلی"},
      {"p": "تیم بازنگری متشکل از مهندسان ارشد موبایل، تحلیل‌گران عملکرد، و متخصصان ابزارهای مهندسی بود. طی سه ماه، این تیم مجموعه‌ای از بررسی‌های عمیق را روی کدبیس انجام داد:"},
      {"ul": [
        {"li": "تحلیل ایستا روی کد: برای شناسایی بخش‌های پیچیده، کدهای تکراری، و کدهای بی‌استفاده."},
        {"li": "رهگیری پویا در زمان راه‌اندازی: بررسی دقیق روند راه‌اندازی برنامه به منظور شناسایی مراحل زمان‌بر که بیشترین سهم را در کندی شروع برنامه داشتند."},
        {"li": "استخراج گراف وابستگی‌ها: برای یافتن فریمورک‌های قدیمی و بی‌استفاده که هنوز در برنامه وجود داشتند."},
        {"li": "دسته‌بندی گزارش‌های خطا: برای شناسایی بخش‌های شکننده‌ی سیستم که منجر به بیشترین تعداد خطا می‌شدند."},
        {"li": "نظرسنجی از توسعه‌دهندگان: جمع‌آوری بازخورد ناشناس از مهندسان در مورد بخش‌هایی از کد که کمترین قابلیت نگهداری را داشتند یا کار با آن‌ها دشوار بود."}
      ]},
      {"p": "یافته‌ها حتی برای اعضای باتجربه‌ی تیم هم شوکه‌کننده بودند:"},
      {"table": {
        "thead": ["شاخص", "وضعیت قبل از بازنگری", "وضعیت هدف", "فاصله"],
        "tbody": [
          ["تعداد خطوط کد (iOS)", "۱.۷ میلیون", "کمتر از ۵۰۰ هزار", "-۱.۲ میلیون"],
          ["تعداد کنترلرها", "۴۰", "کمتر از ۱۰", "-۳۰"],
          ["زمان راه‌اندازی اولی", "۲۰۸۰ میلی‌ثانیه", "۱۰۰۰ میلی‌ثانیه", "-۱۰۸۰ میلی‌ثانیه"],
          ["حجم باینری", "۱۳۰ مگابایت", "۸۰ مگابایت", "-۵۰ مگابایت"]
        ]
      }},
      {"title": "پروژه‌ی LightSpeed — چهار اصل راهنما"},
      {"p": "«در بازنویسی‌های بزرگ این ریسک همواره وجود دارد که پیچیدگی‌های قدیمی، تنها با نوعی پیچیدگی جدید جایگزین شوند. مگر اینکه اصولی شفاف و محدودکننده در تعریف محدوده‌ی کار وجود داشته باشد. تیم مسنجر راهبرد خود را در قالب چهار اصل به ظاهر ساده اما کلیدی تدوین کرد:"},
      {"pBold": "۱. استفاده حداکثری از قابلیت‌های سیستم‌عامل"},
      {"p": "اگر iOS به طور پیش‌فرض یک پارسر JSON سریع و بهینه ارائه می‌دهد، دلیلی برای پیاده‌سازی یک نسخه‌ی سفارشی از آن وجود ندارد. اگر کامپوننت‌های جدید UIKit نیاز ما را برطرف می‌کنند، می‌توان از آن‌ها به جای نسخه‌های شخصی‌سازی‌شده استفاده کرد.تکیه بر فریمورک‌های آزموده‌شده‌ی اپل این امکان را فراهم کرد که بسیاری از لایه‌های اختصاصی حذف شوند و در نتیجه حجم کد و مصرف حافظه کاهش یافت."},
      {"pBold": "۲. استفاده مجدد از رابط کاربری"},
      {"p": "در نسخه‌های قبلی برنامه، حدود چهل کنترلر (View Controller) مختلف وجود داشت که بسیاری از آن‌ها عملکرد و ظاهر بسیار مشابهی داشتند. در LightSpeed این ساختار بازطراحی شد و همه‌ این صفحات در قالب صفحات مبتنی بر الگو (template-driven) پیاده‌سازی شدند. اکنون یک کنترلر واحد می‌تواند فهرست‌ها، صفحات جدولی (grid)، و صفحات جزئیات را تنها با دریافت یک الگوی ساختاری از SQLite تولید کند. به این ترتیب، برای تغییر در چیدمان صفحات دیگر نیازی به انتشار نسخه‌ی جدید کد نیست و تنها کافی است داده‌ها به‌روزرسانی شوند."},
      {"pBold": "۳. بهره‌گیری از SQLite"},
      {"p": "در معماری قبلی مسنجر، داده‌ها عمدتا در حافظه نگهداری می‌شدند و با سیستم‌های تراکنش سفارشی به هم متصل می‌شدند. این لایه‌های اضافی باعث کاهش سرعت و بروز حالات خاص و مرزی می‌شدند. در LightSpeed تمام وضعیت‌های اصلی برنامه در پایگاه‌داده‌ی SQLite ذخیره می‌شوند و رابط کاربری تغییرات این جداول را رصد می‌کند. به این ترتیب، هم‌زمانی، ذخیره‌سازی موقت (Caching)، و مدیریت تراکنش‌ها به شکل رایگان از طریق موتور SQLite فراهم می‌شود."},
      {"pBold": "۴. یک‌‌پارچه‌سازی مسیرهای ارتباطی با سرور"},
      {"p": "در معماری قبلی، هر قابلیت کلاینت به طور مستقل و با پروتکل خاص خود با سرور مربوطه ارتباط برقرار می‌کرد و این باعث پیچیدگی و تکرار در کدهای ارتباطی می‌شد. در LightSpeed یک لایه‌ی واسط سرور (server broker) معرفی شد که همه‌ی ارتباطات شبکه از طریق آن انجام می‌شود.‌این رویکرد باعث شد مسیرهای ارتباطی ساده و متمرکز شوند، کدهای تکراری حذف شوند، و امکان حذف تدریجی APIهای قدیمی فراهم شود."},
      {"title": "از نمونه‌ی اولیه تا بازنویسی کامل: طراحی و پیاده‌سازی هسته جدید"},
      {"p": "پس از آنکه تیم مهندسی با آزمایش‌های اولیه ثابت کرد که کاهش ۷۵ درصدی حجم کد دست‌یافتنی است، روند بازنویسی کامل به چهار فاز (سه‌ماهه) تقسیم شد:"},
      {"ul": [
        {"li": "سه‌ماهه‌ی اول: ساخت هسته‌ی جدید کلاینت، شامل تعریف یک شِمای یکپارچه برای SQLite و طراحی سیستم‌های نظارت بر تغییرات داده‌ها (data observers)."},
        {"li": "سه‌‌ماهه‌‌ی دوم: انتقال قابلیت‌‌های کلیدی (مانند گفت‌‌وگوی متنی، اشتراک‌‌گذاری تصاویر و نوتیفیکیشن‌‌ها) به هسته‌‌ی جدید."},
        {"li": "سه‌‌ماهه‌‌ی سوم: انتقال قابلیت‌‌های پیشرفته‌‌تر (مانند تماس صوتی/تصویری) و تکمیل یکپارچه‌‌سازی‌‌های لازم با سیستم‌‌عامل."},
        {"li": "سه‌‌ماهه‌‌ی چهارم: حذف مسیرهای قدیمی کد، غیرفعال‌‌سازی فریمورک‌‌های قبلی و بهینه‌‌سازی مصرف حافظه."}
      ]},
      {"p": "در تمام این مراحل، تست‌های خودکار به طور همزمان هم روی پشته‌ی قدیمی و هم روی پشته‌ی جدید اجرا می‌شدند تا اطمینان حاصل شود که رفتار برنامه بدون تغییر باقی بماند. چالشی بزرگ برای برنامه‌ای با بیش از یک میلیارد کاربر و صدها حالت خاص."},
      {"p": "در طول این فرآیند، تست‌های خودکار به‌صورت موازی در هر دو معماری قدیم و جدید اجرا شدند تا تضمین کنند عملکرد اپلیکیشن—با میلیاردها کاربر و صدها حالت خاص—بدون تغییر باقی می‌ماند. چالشی بزرگ در مقیاس یک اپلیکیشن جهانی."},
      {"title": "کابوس‌های مهاجرت و پیش‌گیری از وقوع آن‌ها"},
      {"p":  "در روند بازنویسی‌های بزرگ، مهاجرت تدریجی از معماری قدیمی به جدید می‌تواند به یکی از سخت‌ترین بخش‌های کار تبدیل شود. تیم مسنجر با چالش‌های متعددی روبه‌رو بود و برای هرکدام راهکار مشخصی در نظر گرفت:"},
      {"ul": [
        {"li": "یکپارچگی نوشتار در دو سیستم: برای مدت چند ماه، کدهای قدیمی و جدید باید به طور همزمان در دسترس کاربران می‌بودند. در این مدت، هر پیامی که کاربر ارسال می‌کرد باید در هر دو مسیر داده (کد قدیمی و جدید) به درستی ثبت می‌شد و بین دو سیستم کاملا همگام باقی می‌ماند.برای این منظور، تیم مهندسی یک لایه‌ی واسط در سطح پایگاه‌داده ایجاد کرد که نوشتن داده‌ها را به طور همزمان در هر دو شِما انجام می‌داد؛ تا زمانی که بتوان معماری قدیمی را به طور کامل غیرفعال کرد."},
        {"li": "وابستگی‌های خارجی : برخی از کتابخانه‌ها و SDKهای قدیمی که در برنامه استفاده می‌شدند، معادل‌های جدید و سبک‌تری نداشتند. در این موارد، تیم یا آن قابلیت‌ها را از ابتدا به صورت بومی بازنویسی کرد، یا انتقال آن‌ها را به فازهای بعدی پروژه موکول کرد."},
        {"li": "فشار برای افزودن ویژگی‌های جدید: در میانه‌ی این بازنویسی، مدیران محصول همچنان درخواست افزودن قابلیت‌های جدیدی مثل ایموجی‌های تازه، فیلترهای تصویری و ابزارهای گفت‌وگوی تجاری داشتند.برای جلوگیری از بروز مشکلات جدی هنگام ادغام این تغییرات در معماری‌های موازی، تیم رهبری یک بازه‌ی شش‌ماهه‌ی توقف تغییرات (feature freeze) اعلام کرد و در این مدت، تنها روی بازنویسی و انتقال به معماری جدید تمرکز شد."}
      ]},
      {"p": "نتیجه‌ی این رویکرد دقیق و مدیریت‌شده این بود که از گرفتار شدن در دام رایج بازنویسی — طراحی بیش از حد پیچیده‌ی سیستم جدید (مشکل شناخته‌شده‌ی second-system effect) جلوگیری شد."},
      {"title": "دستاورد نهایی: در عمل «۲ برابر سریع‌تر» یعنی چه؟"},
      {"pBold": "پس از ۱۲ ماه، نسخه جدید وارد اپ‌استور شد. آمارها چنین بودند:"},
      {"table": {
        "thead": ["شاخص", "قبل از LightSpeed", "بعد از LightSpeed", "بهبود"],
        "tbody": [
          ["شروع سرد (آیفون ۱۱)", "۲۰۸۰ میلی‌ثانیه", "۱۰۴۰ میلی‌ثانیه", "-۵۰٪"],
          ["حجم باینری", "۱۳۰ مگابایت", "۸۷ مگابایت", "-۳۳٪"],
          ["نرخ کرش / ۱۰۰۰ جلسه", "۳.۷", "۱.۲", "-۶۸٪"],
          ["مسیرهای فعال کد", "۴۰", "۹", "-۷۷٪"],
          ["خطوط کد", "۱.۷ میلیون", "۳۶۰ هزار", "-۷۹٪"]
        ]
      }},
      {"pBold": " زمان راه‌اندازی برنامه به طور محسوسی کاهش یافت و کار با مسنجر روان‌تر و سریع‌تر شد — از باز شدن گفت‌وگوها گرفته تا بارگذاری پیش‌نمایش‌ها. همچنین کاربران دستگاه‌های قدیمی‌تر بهبود چشم‌گیری در کارایی مشاهده کردند.در پشت صحنه نیز تیم توسعه از این بازنویسی سود برد: زمان ساخت پروژه کوتاه‌تر شد، Pull Requestها ساده‌تر و کوچک‌تر شدند، و کد پایه‌ی جدید امکان توسعه‌ی سریع‌تر و پایدارتر در آینده را فراهم کرد."},
      {"title": "درس‌هایی برای تیم‌های مهندسی در مواجهه با بدهی فنی"},
      {"ul": [
        {"li": "همه‌چیز را قابل اندازه‌گیری کنید. بدون داده دقیق نمی‌توانید ضرورت بازنویسی را اثبات کنید."},
        {"li": "قبل از بازنویسی، ارزیابی کامل انجام دهید. ابتدا نقاط بحرانی را شناسایی کنید، نه اینکه کل سیستم را بی‌هدف بازنویسی کنید."},
        {"li": "با نمونه‌ی اولیه‌ی کوچک شروع کنید. اما تأثیر آن را در مقیاس کامل بسنجید؛ پیش از شروع بازنویسی کامل، شواهد کافی از میزان بهبود قابل‌کسب داشته باشید."},
        {"li": "از قابلیت‌های پیش‌فرض سیستم‌عامل استفاده کنید. این کار هم حجم کد را کم می‌کند و هم نگه‌داری آینده را ساده‌تر می‌سازد."},
        {"li": "به کد به چشم یک بدهی نگاه کنید. هر خط کد باید ارزش نگه‌داری داشته باشد، در غیر این‌صورت حذف یا ساده‌سازی شود."},
        {"li": "در بازه‌ای از افزودن ویژگی‌های جدید صرف‌نظر کنید. بدون یک دوره‌ی توقف توسعه، مدیریت همزمان بازنویسی و افزودن ویژگی‌های جدید بسیار پرهزینه و پرریسک خواهد بود."},
        {"li": "در دوره‌ی مهاجرت، داده‌ها را هم‌زمان در هر دو سیستم نگه دارید؛ این کار از بروز مشکلات جدی در تجربه‌ی کاربران جلوگیری می‌کند."}
      ]},
      {"title": "نتیجه‌گیری: کی باید بازنویسی کرد، کی بازسازی، و کی بهتر است کنار گذاشت؟"},
      {"p": "بازنویسی بزرگ پروژه‌ها همیشه ریسک بالایی دارد و ممکن است به بن‌بست یا تاخیرهای طولانی منجر شود. اما وقتی بدهی فنی آنقدر زیاد می‌شود که سرعت توسعه، کیفیت تجربه کاربری یا ظرفیت اپلیکیشن را به شدت محدود می‌کند، بازنویسی می‌تواند تنها راه حل باشد."},
      {"p": "به دنبال نقاط عطف و هشدارهای مهم باشید: وقتی زمان راه‌اندازی به حدی می‌رسد که باعث از دست دادن کاربران می‌شود، وقتی حجم فایل به محدودیت‌های پلتفرم نزدیک می‌شود، یا وقتی جذب و آموزش مهندسین جدید به شدت کند می‌گردد."},
      {"p": "در این شرایط، یک بازنویسی منظم، مبتنی بر داده و حساب‌شده که از یک ارزیابی جامع و دقیق شروع شده باشد، می‌تواند اپلیکیشن را به مسیر رشد و توسعه سریع‌تر بازگرداند.در نهایت، موفقیت مسنجر به ما یادآوری می‌کند که مراقبت از سلامت نرم‌افزار یک روند دائمی است؛ باید زود ارزیابی کرد، مداوم سنجید و نترسید از حذف حجم زیادی کد برای رسیدن به آینده‌ای سریع‌تر و تمیزتر."}
    ]
}
